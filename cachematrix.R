## Put comments here that give an overall description of what your
## functions do

## creates a special matrix that can cache its inverse

makeCacheMatrix <- function(x = numeric()) {
	m <- NULL					## init cache as NULL in make env
	set <- function(y) {			## create new function to set
		x <<- y				## set existing value of x to be y
		m <<- NULL				## when setting a new matrix clear cache
	}
	get <- function() x			## create function get that returns value of x as called 					
	
	setinv <- function(inv) m <<- inv   ## function to set existing value of cache to inv
							## should overwrite null m when called  
	
	getinv <- function() m 			## function to get value of m in make env
							## should return NULL when called first time
							## should return inv when called second time

	list(set = set, get = get,		## creates list of function names to be called 
		setinv = setinv,
		getinv = getinv)
}


## Calculates the inverse of the matrix if called for the first time and pulls the inverse
##from the cache if called a second time. Input is the output of makeCacheMatrix

cacheSolve <- function(x, ...) {
      ## Return a matrix that is the inverse of 'x'
	m <- x$getinv()				## check getinv in list generated by make function
							## should be null on first call
	if(!is.null(m)) {				## is m non null? if yes, return it
		message("getting cached data")
		return(m)
	}
	data <- x$get()				## get the data we need			
	m <- solve(data,...)			## set local m as inv on matrix 
	x$setinv(m)					## use local value of m to set as global value of m 
	m						## return inv
}
